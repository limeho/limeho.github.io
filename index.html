<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:functionSet</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="function">Function</h1>
<h5 id="-">函数的声明与赋值</h5>
<pre><code class="lang-javascript">// 函数的声明------------------------
// 1.直接声明函数
a();
function a(){
  alert(&#39;...&#39;);
}
//函数的声明会优先读取，无论函数的执行语句放在声明前面还是后面都会正常执行

// 2.表达式方法定义函数
var a = function(){
     alert(&#39;...&#39;);
}
a();
//函数的定义不会优先加载，函数的执行语句必须放在定义的后面，否则会报错。

// 3.以上两种方法结合
var b = function a(){
    alert(&#39;x&#39;x&#39;x&#39;);
}

//直接执行函数a
a(); 
//结果会报错，不能识别a

//执行函数b
b();
//正常执行，打印出xxx
//这种定义方式相当于把匿名函数赋值给b

// 函数的赋值-------------------------
//声明一个函数
function a(){
        var i=1；
        return i;
    }
//打印出函数名
alert(a);  会把整个函数的代码打印出来

//打印出函数名（带括号）
alert(a()); 会打印出函数返回值，1

//直接赋值函数名
var b = a;  会把整个函数赋值过去

//赋值函数名（带括号）
var b = a(); 赋值的是函数的返回值，1

//如果这样赋值
var b = function a(){ 
        var i=1；
        return i;
    }
同 var b = a 赋值方法类似
</code></pre>
<h5 id="-">构造函数</h5>
<p>构造函数是专门用于创建对象的函数，如果一个函数使用 <code>new</code> 关键字调用，那么这个函数就是构造函数。</p>
<pre><code class="lang-javascript">  // 定义函数
  function foo() {
    console.log(&#39;通过 new 也能调用函数...&#39;);
  }
  // 调用函数
  new foo;
</code></pre>
<h5 id="-">实例成员</h5>
<p>通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。</p>
<pre><code class="lang-javascript">// 构造函数
  function Person() {
    // 构造函数内部的 this 就是实例对象
    // 实例对象中动态添加属性
    this.name = &#39;小明&#39;
    // 实例对象动态添加方法
    this.sayHi = function () {
      console.log(&#39;大家好~&#39;)
    }
  }
  // 实例化，p1 是实例对象
  // p1 实际就是 构造函数内部的 this
  const p1 = new Person()
  console.log(p1)
  console.log(p1.name) // 访问实例属性
  p1.sayHi() // 调用实例方法
</code></pre>
<h5 id="-">静态成员</h5>
<p>在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。</p>
<pre><code class="lang-javascript">// 构造函数
  function Person(name, age) {
    // 省略实例成员
  }
  // 静态属性
  Person.eyes = 2
  Person.arms = 2
  // 静态方法
  Person.walk = function () {
    console.log(&#39;^_^人都会走路...&#39;)
    // this 指向 Person
    console.log(this.eyes)
  }
</code></pre>
<p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
<pre><code class="lang-javascript">const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2
</code></pre>
<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<pre><code class="lang-javascript">const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42
</code></pre>
<p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<blockquote>
<p><strong>备注：</strong> 该方法的语法和作用与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply()</code></a> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>
</blockquote>
<pre><code class="lang-javascript">function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = &#39;food&#39;;
}

console.log(new Food(&#39;cheese&#39;, 5).name);
// expected output: &quot;cheese&quot;
</code></pre>
<p><code>toString()</code> 方法返回一个表示当前函数源代码的字符串。</p>
<pre><code class="lang-javascript">function sum(a, b) {
  return a + b;
}

console.log(sum.toString());
// expected output: &quot;function sum(a, b) {
//                     return a + b;
//                   }&quot;

console.log(Math.abs.toString());
// expected output: &quot;function abs() { [native code] }&quot;
</code></pre>
<h1 id="-">内置构造函数</h1>
<h2 id="array">Array</h2>
<h5 id="array-">Array的创建与赋值</h5>
<pre><code class="lang-javascript">// 创建：-----------------------
// 构造函数创建数组
  let arr = new Array(5, 7, 8);

  // 字面量方式创建数组
  let list = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]

//赋值：------------------------
// 方法一：
var arr = new Array();   //长度可以指定，也可以不指定，js的数组是变长的，会随着加入的元素改变数组的长度
arr[0] = 1;
arr[1] = 2;

// 方法二：
var arr = new Array(1,2);  //创建数组的同时赋值

// 方法三：
var arr = [1,2];   //直接输入一个数组，也叫字面量数组
</code></pre>
<p><code>concat()</code>方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<p><strong><em>合并两个数组，返回生成新数组</em></strong></p>
<pre><code class="lang-javascript">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
const array2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
const array3 = array1.concat(array2);

console.log(array3);
// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
</code></pre>
<p>##### </p>
<p><code>every()</code> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p>
<p><strong><em>检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回true，否则返回false</em></strong></p>
<blockquote>
<p><strong>备注：</strong> 若收到一个空数组，此方法在任何情况下都会返回 <code>true</code>。</p>
</blockquote>
<pre><code class="lang-javascript">const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
</code></pre>
<p>##### </p>
<p><code>filter()</code> 方法创建给定数组一部分的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy">浅拷贝 (en-US)</a>，其包含通过所提供函数实现的测试的所有元素。</p>
<p><strong><em>过滤数组   筛选数组元素，并生成新数组</em></strong></p>
<pre><code class="lang-javascript">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];

const result = words.filter(word =&gt; word.length &gt; 6);

console.log(result);
// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]
</code></pre>
<p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。</p>
<p><strong><em>查找元素，返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回underfined</em></strong></p>
<pre><code class="lang-javascript">const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element =&gt; element &gt; 10);

console.log(found);
// expected output: 12
</code></pre>
<p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。</p>
<p><strong><em>查找元素的索引值</em></strong></p>
<pre><code class="lang-javascript">const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) =&gt; element &gt; 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3
</code></pre>
<p><code>forEach()</code> 方法对数组的每个元素执行一次给定的函数。</p>
<p><strong><em>遍历数组   不返回，用于不改变值，经常用于查找打印输出值</em></strong></p>
<pre><code class="lang-javascript">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

array1.forEach(element =&gt; console.log(element));

// expected output: &quot;a&quot;
// expected output: &quot;b&quot;
// expected output: &quot;c&quot;
</code></pre>
<p><code>includes()</code>方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="lang-javascript">const array1 = [1, 2, 3];

console.log(array1.includes(2));
// expected output: true

const pets = [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];

console.log(pets.includes(&#39;cat&#39;));
// expected output: true

console.log(pets.includes(&#39;at&#39;));
// expected output: false
</code></pre>
<p><code>indexOf()</code>方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。</p>
<pre><code class="lang-javascript">const beasts = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;bison&#39;];

console.log(beasts.indexOf(&#39;bison&#39;));
// expected output: 1

// start from index 2
console.log(beasts.indexOf(&#39;bison&#39;, 2));
// expected output: 4

console.log(beasts.indexOf(&#39;giraffe&#39;));
// expected output: -1
</code></pre>
<p><code>Array.isArray()</code>用于确定传递的值是否是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>。</p>
<pre><code class="lang-javascript">Array.isArray([1, 2, 3]);  // true
Array.isArray({foo: 123}); // false
Array.isArray(&#39;foobar&#39;);   // false
Array.isArray(undefined);  // false
</code></pre>
<p><code>Array.from()</code> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
<p><em>将伪数组转为数组</em></p>
<pre><code class="lang-javascript">console.log(Array.from(&#39;foo&#39;));
// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]

console.log(Array.from([1, 2, 3], x =&gt; x + x));
// expected output: Array [2, 4, 6]
</code></pre>
<p><code>join()</code> 方法将一个数组（或一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>
<p><strong><em>数组元素拼接为字符串，返回字符串</em></strong></p>
<pre><code class="lang-javascript">const elements = [&#39;Fire&#39;, &#39;Air&#39;, &#39;Water&#39;];

console.log(elements.join());
// expected output: &quot;Fire,Air,Water&quot;

console.log(elements.join(&#39;&#39;));
// expected output: &quot;FireAirWater&quot;

console.log(elements.join(&#39;-&#39;));
// expected output: &quot;Fire-Air-Water&quot;
</code></pre>
<p><code>map()</code> 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p>
<p><strong><em>迭代数组   返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据</em></strong></p>
<pre><code class="lang-javascript">const array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x =&gt; x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]
</code></pre>
<p><code>pop()</code>方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。</p>
<pre><code class="lang-javascript">const plants = [&#39;broccoli&#39;, &#39;cauliflower&#39;, &#39;cabbage&#39;, &#39;kale&#39;, &#39;tomato&#39;];

console.log(plants.pop());
// expected output: &quot;tomato&quot;

console.log(plants);
// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]

plants.pop();

console.log(plants);
// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;]
</code></pre>
<p><code>push()</code>方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</p>
<pre><code class="lang-javascript">const animals = [&#39;pigs&#39;, &#39;goats&#39;, &#39;sheep&#39;];

const count = animals.push(&#39;cows&#39;);
console.log(count);
// expected output: 4
console.log(animals);
// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]

animals.push(&#39;chickens&#39;, &#39;cats&#39;, &#39;dogs&#39;);
console.log(animals);
// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;, &quot;cats&quot;, &quot;dogs&quot;]
</code></pre>
<p><code>reduce()</code> 方法对数组中的每个元素按序执行一个由您提供的 <strong>reducer</strong> 函数，每一次运行 <strong>reducer</strong> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p>
<p>第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 <em>initialValue</em>，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。</p>
<pre><code class="lang-javascript">const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) =&gt; previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial);
// expected output: 10
</code></pre>
<p><code>reverse()</code> 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<pre><code class="lang-javascript">const array1 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];
console.log(&#39;array1:&#39;, array1);
// expected output: &quot;array1:&quot; Array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

const reversed = array1.reverse();
console.log(&#39;reversed:&#39;, reversed);
// expected output: &quot;reversed:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]

// Careful: reverse is destructive -- it changes the original array.
console.log(&#39;array1:&#39;, array1);
// expected output: &quot;array1:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]
</code></pre>
<p><code>shift()</code> 方法从数组中删除<strong>第一个</strong>元素，并返回该元素的值。此方法更改数组的长度。</p>
<pre><code class="lang-javascript">const array1 = [1, 2, 3];

const firstElement = array1.shift();

console.log(array1);
// expected output: Array [2, 3]

console.log(firstElement);
// expected output: 1
</code></pre>
<p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p>
<pre><code class="lang-javascript">const animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;];

console.log(animals.slice(2));
// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]

console.log(animals.slice(2, 4));
// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]

console.log(animals.slice(1, 5));
// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]

console.log(animals.slice(-2));
// expected output: Array [&quot;duck&quot;, &quot;elephant&quot;]

console.log(animals.slice(2, -1));
// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]

console.log(animals.slice());
// expected output: Array [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]
</code></pre>
<p><code>some()</code> 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。</p>
<blockquote>
<p><strong>备注：</strong> 如果用一个空数组进行测试，在任何情况下它返回的都是<code>false</code>。</p>
</blockquote>
<pre><code class="lang-javascript">const array = [1, 2, 3, 4, 5];

// checks whether an element is even
const even = (element) =&gt; element % 2 === 0;

console.log(array.some(even));
// expected output: true
</code></pre>
<p><code>sort()</code>方法用<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法</a>对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的。</p>
<p><strong><em>对原数组单元值排序</em></strong></p>
<pre><code class="lang-javascript">const months = [&#39;March&#39;, &#39;Jan&#39;, &#39;Feb&#39;, &#39;Dec&#39;];
months.sort();
console.log(months);
// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]

const array1 = [1, 30, 4, 21, 100000];
array1.sort();
console.log(array1);
// expected output: Array [1, 100000, 21, 30, 4]
</code></pre>
<p>##### </p>
<p><code>splice()</code> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。</p>
<p><strong><em>删除或替换原数组单元</em></strong></p>
<pre><code class="lang-javascript">const months = [&#39;Jan&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;];
months.splice(1, 0, &#39;Feb&#39;);
// inserts at index 1
console.log(months);
// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]

months.splice(4, 1, &#39;May&#39;);
// replaces 1 element at index 4
console.log(months);
// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]
</code></pre>
<p><code>toString()</code> 方法返回一个字符串，表示指定的数组及其元素。</p>
<pre><code class="lang-javascript">const array1 = [1, 2, &#39;a&#39;, &#39;1a&#39;];

console.log(array1.toString());
// expected output: &quot;1,2,a,1a&quot;
</code></pre>
<p><code>unshift()</code> 方法将一个或多个元素添加到数组的<strong>开头</strong>，并返回该数组的<strong>新长度</strong>。</p>
<pre><code class="lang-javascript">const array1 = [1, 2, 3];

console.log(array1.unshift(4, 5));
// expected output: 5

console.log(array1);
// expected output: Array [4, 5, 1, 2, 3]
</code></pre>
<h2 id="object">Object</h2>
<h5 id="js-">js创建对象并赋值其属性</h5>
<pre><code class="lang-javascript">// 对象定义
var obj = new Object();  // 或
var obj = {};            // &lt;--- 
// 添加属性
obj.name = &#39;tom&#39;;
obj.ses=&#39;man&#39;;
// 添加方法
obj.say = function(){
alert(&#39;22222&#39;);
}
// 调用 
obj.say();
// 修改属性
obj.name=&#39;jack&#39;;
// 删除属性
obj.name = undefined;
obj.say = undefined;
// 其name、say属性仍存在obj对象中，怎样才能在obj中移除name属性呢？
delete obj.name;
</code></pre>
<h5 id="-">创建对象的三种方式</h5>
<pre><code class="lang-javascript">// 通过构造函数创建普通对象
  const user = new Object({name: &#39;小明&#39;, age: 15})

  // 这种方式声明的变量称为【字面量】
  let student = {name: &#39;杜子腾&#39;, age: 21}

  // 对象语法简写
  let name = &#39;小红&#39;;
  let people = {
    // 相当于 name: name
    name,
    // 相当于 walk: function () {}
    walk () {
      console.log(&#39;人都要走路...&#39;);
    }
  }

  console.log(student.constructor);
  console.log(user.constructor);
  console.log(student instanceof Object);
</code></pre>
<h5 id="-">变量的使用</h5>
<pre><code class="lang-javascript">var v1 = obj.abc;//使用点的方式
var v2 = obj[&quot;abc&quot;];//使用中括号的方式   中括号[]中的值为变量时 ，只能选择该项
</code></pre>
<p><code>Object.assign()</code> 方法将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（<code>Object.propertyIsEnumerable()</code> 返回 true）的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">自有</a>（<code>Object.hasOwnProperty()</code> 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。</p>
<pre><code class="lang-javascript">const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
</code></pre>
<p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。</p>
<pre><code class="lang-javascript">const object1 = {
  a: &#39;somestring&#39;,
  b: 42,
  c: false
};

console.log(Object.keys(object1));
// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<p><strong><code>Object.values()</code></strong>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<pre><code class="lang-javascript">Object.values(obj)

var obj = { foo: &#39;bar&#39;, baz: 42 };
console.log(Object.values(obj)); // [&#39;bar&#39;, 42]

// array like object
var obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };
console.log(Object.values(obj)); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };
console.log(Object.values(an_obj)); // [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]

// getFoo is property which isn&#39;t enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = &#39;bar&#39;;
console.log(Object.values(my_obj)); // [&#39;bar&#39;]

// non-object argument will be coerced to an object
console.log(Object.values(&#39;foo&#39;)); // [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]
</code></pre>
<h2 id="string">String</h2>
<p>String 的创建方式</p>
<pre><code class="lang-javascript">  // 1.使用构造函数创建字符串
  let str = new String(&#39;hello world!&#39;);

  // 2.字面量创建字符串
  let str2 = &#39;你好，世界！&#39;;

  // 检测是否属于同一个构造函数
  console.log(str.constructor === str2.constructor); // true
  console.log(str instanceof String); // false
</code></pre>
<p><code>concat()</code> 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p>
<pre><code class="lang-javascript">let hello = &#39;Hello, &#39;
console.log(hello.concat(&#39;Kevin&#39;, &#39;. Have a nice day.&#39;))
// Hello, Kevin. Have a nice day.

let greetList = [&#39;Hello&#39;, &#39; &#39;, &#39;Venkat&#39;, &#39;!&#39;]
&quot;&quot;.concat(...greetList)  // &quot;Hello Venkat!&quot;

&quot;&quot;.concat({})    // [object Object]
&quot;&quot;.concat([])    // &quot;&quot;
&quot;&quot;.concat(null)  // &quot;null&quot;
&quot;&quot;.concat(true)  // &quot;true&quot;
&quot;&quot;.concat(4, 5)  // &quot;45&quot;
</code></pre>
<p><code>endsWith()</code> 方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</p>
<pre><code class="lang-javascript">var str = &quot;To be, or not to be, that is the question.&quot;;

alert( str.endsWith(&quot;question.&quot;) );  // true
alert( str.endsWith(&quot;to be&quot;) );      // false
alert( str.endsWith(&quot;to be&quot;, 19) );  // true
</code></pre>
<p><code>includes()</code> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p>
<pre><code class="lang-javascript">var str = &#39;To be, or not to be, that is the question.&#39;;

console.log(str.includes(&#39;To be&#39;));       // true
console.log(str.includes(&#39;question&#39;));    // true
console.log(str.includes(&#39;nonexistent&#39;)); // false
console.log(str.includes(&#39;To be&#39;, 1));    // false
console.log(str.includes(&#39;TO BE&#39;));       // false
</code></pre>
<p><code>indexOf()</code> 方法，给定一个参数：要搜索的子字符串，搜索整个调用字符串，并返回指定子字符串第一次出现的索引。给定第二个参数：一个数字，该方法将返回指定子字符串在大于或等于指定数字的索引处的第一次出现。</p>
<pre><code class="lang-javascript">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;

const searchTerm = &#39;dog&#39;;
const indexOfFirst = paragraph.indexOf(searchTerm);

console.log(`The index of the first &quot;${searchTerm}&quot; from the beginning is ${indexOfFirst}`);
// expected output: &quot;The index of the first &quot;dog&quot; from the beginning is 40&quot;

console.log(`The index of the 2nd &quot;${searchTerm}&quot; is ${paragraph.indexOf(searchTerm, (indexOfFirst + 1))}`);
// expected output: &quot;The index of the 2nd &quot;dog&quot; is 52&quot;
</code></pre>
<p><code>match()</code> 方法检索返回一个字符串匹配正则表达式的结果。</p>
<pre><code class="lang-javascript">const paragraph = &#39;The quick brown fox jumps over the lazy dog. It barked.&#39;;
const regex = /[A-Z]/g;
const found = paragraph.match(regex);

console.log(found);
// expected output: Array [&quot;T&quot;, &quot;I&quot;]
</code></pre>
<p><code>replace()</code> 方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。模式可以是一个字符串或者一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<strong>如果pattern是字符串，则仅替换第一个匹配项。</strong></p>
<pre><code class="lang-javascript">const p = &#39;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#39;;

console.log(p.replace(&#39;dog&#39;, &#39;monkey&#39;));
// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;


const regex = /Dog/i;
console.log(p.replace(regex, &#39;ferret&#39;));
// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?&quot;
</code></pre>
<p><code>slice()</code> 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。</p>
<pre><code class="lang-javascript">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;

console.log(str.slice(31));
// expected output: &quot;the lazy dog.&quot;

console.log(str.slice(4, 19));
// expected output: &quot;quick brown fox&quot;

console.log(str.slice(-4));
// expected output: &quot;dog.&quot;

console.log(str.slice(-9, -5));
// expected output: &quot;lazy&quot;
</code></pre>
<p><code>split()</code> 方法使用指定的分隔符字符串将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。</p>
<pre><code class="lang-javascript">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;

const words = str.split(&#39; &#39;);
console.log(words[3]);
// expected output: &quot;fox&quot;

const chars = str.split(&#39;&#39;);
console.log(chars[8]);
// expected output: &quot;k&quot;

const strCopy = str.split();
console.log(strCopy);
// expected output: Array [&quot;The quick brown fox jumps over the lazy dog.&quot;]
</code></pre>
<p><code>startsWith()</code> 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 <code>true</code> 或 <code>false</code>。</p>
<pre><code class="lang-javascript">const str1 = &#39;Saturday night plans&#39;;

console.log(str1.startsWith(&#39;Sat&#39;));
// expected output: true

console.log(str1.startsWith(&#39;Sat&#39;, 3));
// expected output: false
</code></pre>
<p><strong><code>toLocaleUpperCase()</code></strong> 方法根据本地主机语言环境把字符串转换为大写格式，并返回转换后的字符串。</p>
<pre><code class="lang-javascript">const city = &#39;istanbul&#39;;

console.log(city.toLocaleUpperCase(&#39;en-US&#39;));
// expected output: &quot;ISTANBUL&quot;

console.log(city.toLocaleUpperCase(&#39;TR&#39;));
// expected output: &quot;İSTANBUL&quot;
</code></pre>
<p><strong><code>toLowerCase()</code></strong> 会将调用该方法的字符串值转为小写形式，并返回。</p>
<pre><code class="lang-javascript">console.log(&#39;中文简体 zh-CN || zh-Hans&#39;.toLowerCase());
// 中文简体 zh-cn || zh-hans

console.log( &quot;ALPHABET&quot;.toLowerCase() );
// &quot;alphabet&quot;
</code></pre>
<p>字符串对象的 <strong><code>toString()</code></strong> 方法返回一个字符串，表示指定的字符串。</p>
<pre><code class="lang-javascript">const stringObj = new String(&#39;foo&#39;);

console.log(stringObj);
// expected output: String { &quot;foo&quot; }

console.log(stringObj.toString());
// expected output: &quot;foo&quot;
</code></pre>
<p><strong><code>toUpperCase()</code></strong> 方法将调用该方法的字符串转为大写形式并返回（如果调用该方法的值不是字符串类型会被强制转换）。</p>
<pre><code class="lang-javascript">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;

console.log(sentence.toUpperCase());
// expected output: &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.&quot;
</code></pre>
<p><strong><code>trim()</code></strong> 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR 等）。</p>
<pre><code class="lang-javascript">const greeting = &#39;   Hello world!   &#39;;

console.log(greeting);
// expected output: &quot;   Hello world!   &quot;;

console.log(greeting.trim());
// expected output: &quot;Hello world!&quot;;
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>